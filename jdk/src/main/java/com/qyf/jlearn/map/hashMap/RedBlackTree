红黑树动画在线演示：https://rbtree.phpisfuture.com/

https://blog.csdn.net/Troy_kfrozen/article/details/78890297

发现JDK1.8对于HashMap的实现引入了红黑树来处理哈希冲突以提高性能（戳这里，有详述），而红黑树的数据结构和操作都是较为复杂的，自己看得过程中有些地方也反复了多次。。。俗话说得好，好记性不如烂笔头，因此决定写下这篇笔记供自己和需要的人日后参考。在开始之前，首先要感谢张拭心同学的这两篇关于红黑树和二叉查找树的文章：

http://blog.csdn.net/u011240877/article/details/53242179

http://blog.csdn.net/u011240877/article/details/53329023

这两篇文章讲得十分详细，使我受益匪浅，在这里也强烈推荐大家阅读一下。由于拭心同学的文章在分析二叉查找树的查找，插入和删除时引用的是递归的实现，为了不重复，本文分析时将采用循环的实现，为大家提供另一种思路。

OK，正式开始，何为红黑树？红黑树（Red-Black Tree） 是一种自平衡二叉查找树，其每个节点都带有黑或红的颜色属性。由于它的本质也是一种二叉查找树，因此它的查找，插入和删除操作均以二叉查找树的对应操作作为基础；但由于红黑树自身要保证平衡（也即要始终满足其五条特性，这个下文会有详述），每次插入和删除之后它都要进行额外的调整，以恢复自身的平衡，这是它与普通二叉查找树不同的地方，也正因为如此，红黑树的查找，插入和删除操作在最坏情况下的时间复杂度也能保证为O(logN)，其中N为树中元素个数。

既然红黑树本质是二叉查找树，那么就有必要先来看一下二叉查找树的相关知识。

二叉查找树

二叉查找树（Binary Search Tree），又名二叉排序树，二叉搜索树，B树。顾名思义，它的节点是可比较的并且具有以下性质：

a. 若左子树不为空，则根节点的值大于其所有左子树中节点的值；
b. 若右子树不为空，则根节点的值小于或等于其所有右子树中节点的值；
c. 左右子树也分别为二叉查找树；
d. 没有键值相等的节点。

由于以上性质，中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望 O(logN)，最坏 O(N)（数列有序，树退化成线性表）。

这里先给出一个二叉查找树节点的结构，下文代码中就用它作为树节点的类：

class BSTNode{
    int value;  //节点的值
    BSTNode left;  //节点的左子树
    BSTNode right;  //节点的右子树
    BSTNode parent;  //节点的父节点

    BSTNode(int value, BSTNode parent) {
        this.value = value;
        this.parent = parent;
    }

    @Override
    public boolean equals(Object obj)
    {
          //两个节点的value相等，则认为两个节点相等
        return (obj instanceof BSTNode) && (((BSTNode) obj).value == this.value);
    }
}

下面就分别看一下二叉查找树的查找，插入和删除操作的实现，此处采用循环来实现。

查找
在二叉搜索树T中查找key的过程为：

a. 若T是空树，则搜索失败，否则：
b. 若key等于T的根节点的数据域之值，则查找成功；否则：
c. 若key小于T的根节点的数据域之值，则搜索左子树；否则：
d. 查找右子树。


####红黑树

上文提到过，红黑树是每个节点都带有颜色属性（红或黑）的二叉查找树。在二叉查找树性质的基础上，红黑树额外规定了以下五条性质。这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

红黑树的查找操作与普通二叉查找树的完全相同，而在进行插入和删除时则有可能导致其不再满足红黑树的性质，因此在这种情况下需要通过节点颜色变更和不超过三次的节点旋转（包括左旋和右旋，对于插入操作最多旋转两次）来使其恢复平衡，操作复杂度为O(logN)。下面一一来分析。

五条性质

a. 每个结点非黑即红；
b. 根结点是黑的；
c. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的；
d. 如果一个结点是红的，那么它的两个儿子都是黑的；
e. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。

只有满足这五条性质的二叉查找树才是一棵红黑树，那么当有插入删除操作导致树的平衡被破坏时，就需要通过下面的节点左右旋转操作来重新保证这五条性质，从而恢复红黑树的平衡。

左旋
首先说明的是，左旋或右旋都是针对一个节点的操作，而非以整棵树为对象。

先来看对节点X的左旋，X是红黑树中的一个节点，假设其左右孩子都存在，并且左孩子为T，右孩子为Z，即X.left=T, X.right=Z。那么对X左旋的过程为：
a. 将X变为其右孩子Z的左孩子，即Z替代X成为这一部分树的根节点；
b. 将Z原本的左孩子（可能为空）变为X的新右孩子；
c. 让Z与X原先的父节点相认（若X原先没有父节点，则Z成为整颗红黑树的新的根节点）。

右旋
针对节点X的右旋
a. 将X变为其左孩子T的右孩子，即T替代X成为这一部分树的根节点；
b. 将T原本的右孩子（可能为空）变为X的新左孩子；
c. 让T与X原先的父节点相认（若X原先没有父节点，则T成为整颗红黑树的新的根节点）。


//x就是上文中说到的replacement
static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root, TreeNode<K,V> x) {
    for (TreeNode<K,V> xp, xpl, xpr;;)  {
        if (x == null || x == root)
            return root; //x为空或x为根节点，返回
        else if ((xp = x.parent) == null) {
            x.red = false; //x为根节点，染成黑色，返回
            return x;
        }
        else if (x.red) {
            x.red = false;
            return root; //x为红色，则无需调整，返回
        }
        //x为其父节点的左孩子
        else if ((xpl = xp.left) == x) {
            if ((xpr = xp.right) != null && xpr.red) { //有红色的兄弟节点xpr，则父亲节点xp必为黑色
                xpr.red = false; //兄弟染成黑色
                xp.red = true; //父亲染成红色
                root = rotateLeft(root, xp); //对父节点xp做左旋转
                xpr = (xp = x.parent) == null ? null : xp.right; //重新将xp指向原先x的父节点，xpr则指向xp新的右孩子
            }
            if (xpr == null)
                x = xp; //若新的xpr为空，即上图中L节点为空，则向上继续调整，将x的父节点xp作为新的x继续循环
            else {
                //此时的xpr就是上图中的节点L，sl和sr就是其左右孩子
                TreeNode<K,V> sl = xpr.left, sr = xpr.right;
                if ((sr == null || !sr.red) &&
                    (sl == null || !sl.red)) {
                    xpr.red = true; //若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红
                    x = xp; //本轮结束，继续向上循环，这就是上图中的情况，新的x即为红色的P节点，下一次循环时P会被染黑，然后循环结束
                }
                else {
                    //否则的话，就需要进一步调整
                    //现在的情况是被删除的X的路径需要一个新的黑色节点，即上图中P的左子树中，只能考虑从P的右子树搬运
                    //所以最终要做的是对P做左旋，但L的左子树sl会在左旋后变为P的右子树，因此在左旋之前需要对sl和sr做处理
                    if (sr == null || !sr.red) {
                        if (sl != null) //若左孩子为红，右孩子不存在或为黑
                            sl.red = false; //左孩子染黑
                        xpr.red = true; //将xpr染红
                        root = rotateRight(root, xpr); //此时考虑上图，P和L均为红，于是需要右旋L将黑色的sl换过来
                        xpr = (xp = x.parent) == null ?
                            null : xp.right;  //右旋后，xpr指向xp（上图P）的新右孩子，即上一步中的sl
                    }
                    if (xpr != null) {
                        xpr.red = (xp == null) ? false : xp.red; //xpr染成跟父节点一致的颜色，为后面父节点xp的左旋做准备
                        if ((sr = xpr.right) != null)
                            sr.red = false; //xpr新的右孩子染黑，防止出现两个红色相连
                    }
                    if (xp != null) {
                        xp.red = false; //将xp染黑，并对其左旋，这样就能保证被删除的X所在的路径又多了一个黑色节点，从而达到恢复平衡的目的
                        root = rotateLeft(root, xp);
                    }
                    //到此调整已经完毕，故将x置为root，进入下一次循环后将直接退出
                    x = root;
                }
            }
        }
        //x为其父节点的右孩子，与上述过程对称
        else { // symmetric
            if (xpl != null && xpl.red) {
                xpl.red = false;
                xp.red = true;
                root = rotateRight(root, xp);
                xpl = (xp = x.parent) == null ? null : xp.left;
            }
            if (xpl == null)
                x = xp;
            else {
                TreeNode<K,V> sl = xpl.left, sr = xpl.right;
                if ((sl == null || !sl.red) &&
                    (sr == null || !sr.red)) {
                    xpl.red = true;
                    x = xp;
                }
                else {
                    if (sl == null || !sl.red) {
                        if (sr != null)
                            sr.red = false;
                        xpl.red = true;
                        root = rotateLeft(root, xpl);
                        xpl = (xp = x.parent) == null ?
                            null : xp.left;
                    }
                    if (xpl != null) {
                        xpl.red = (xp == null) ? false : xp.red;
                        if ((sl = xpl.left) != null)
                            sl.red = false;
                    }
                    if (xp != null) {
                        xp.red = false;
                        root = rotateRight(root, xp);
                    }
                    x = root;
                }
            }
        }
    }
}

以上就是HashMap中对于红黑树删除后调整的实现，逻辑很绕，但最终的目的就是让整棵树再次满足红黑树的5条特性。

最后
红黑树是一种特殊的二叉查找树，它的五条特性保证了其查找，插入和删除操作的复杂度均为O(logN)。
红黑树的查找算法和二叉查找树无异，插入和删除也是基于二叉查找树的做法，只是在其基础上需要进行调整以重新恢复树的平衡（主要是重新满足第4，5条特性）。
由于其有序，快速的特点，红黑树在很多场景下都有被应用，比如Java中的TreeMap，以及Java 8中的HashMap。


红黑树的左旋右旋
      y       右旋--->    x
   x    γ              α    y
 α  β         <---左旋     β   γ

红黑树的左右旋是比较重要的操作，左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。

比如 X 左旋(右图转成左图)的结果，是让在 Y 左子树的黑色节点跑到 X 右子树去。

我们以 Java 集合框架中的 TreeMap 中的代码来看下左右旋的具体操作方法：

指定节点 x 的左旋 (右图转成左图)：

//这里 p 代表 x
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> r = p.right; // p 是上图中的 x，r 就是 y
        p.right = r.left;       // 左旋后，x 的右子树变成了 y 的左子树 β
        if (r.left != null)
            r.left.parent = p;  //β 确认父亲为 x
        r.parent = p.parent;        //y 取代 x 的第一步：认 x 的父亲为爹
        if (p.parent == null)       //要是 x 没有父亲，那 y 就是最老的根节点
            root = r;
        else if (p.parent.left == p) //如果 x 有父亲并且是它父亲的左孩子，x 的父亲现在认 y 为左孩子，不要 x 了
            p.parent.left = r;
        else                            //如果 x 是父亲的右孩子，父亲就认 y 为右孩子，抛弃 x
            p.parent.right = r;
        r.left = p;     //y 逆袭成功，以前的爸爸 x 现在成了它的左孩子
        p.parent = r;
    }
}

可以看到，x 节点的左旋就是把 x 变成 右孩子 y 的左孩子，同时把 y 的左孩子送给 x 当右子树。

简单点记就是：左旋把右子树里的一个节点（上图 β）移动到了左子树。

指定节点 y 的右旋（左图转成右图）：

private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> l = p.left;
        p.left = l.right;
        if (l.right != null) l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}
同理，y 节点的右旋就是把 y 变成 左孩子 x 的右孩子，同时把 x 的右孩子送给 x 当左子树。

简单点记就是：右旋把左子树里的一个节点（上图 β）移动到了右子树。

了解左旋、右旋的方法及意义后，就可以了解红黑树的主要操作：插入、删除。

红黑树的平衡插入
红黑树的插入主要分两步：

首先和二叉查找树的插入一样，查找、插入
然后调整结构，保证满足红黑树状态
对结点进行重新着色
以及对树进行相关的旋转操作
红黑树的插入在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。

总结
红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。

红黑树的插入、删除调整逻辑比较复杂，但最终目的是满足红黑树的 5 个特性，尤其是 4 和 5。

在插入调整时为了简化操作我们直接把插入的节点涂成红色，这样只要保证插入节点的父节点不是红色就可以了。

而在删除后的调整中，针对删除黑色节点，所在子树缺少一个节点，需要进行弥补或者对别人造成一个黑色节点的伤害。具体调整方法取决于兄弟节点所在子树的情况。

红黑树的插入、删除在树形数据结构中算比较复杂的，理解起来比较难，但只要记住，红黑树有其特殊的平衡规则，而我们为了维持平衡，根据邻树的状况进行旋转或者涂色。

红黑树这么难理解，必定有其过人之处。它的有序、快速特性在很多场景下都有用到，比如 Java 集合框架的 TreeMap, TreeSet 等。

Thanks
@ coolingxyz 前辈写过数据结构相关的课件，flash 动态演示数据结构算法，可以去看看：
http://xu-laoshi.cn/shujujiegou/flash.html

一个不错的在线演示添加、删除红黑树：
http://sandbox.runjs.cn/show/2nngvn8w

《算法导论》
http://en.wikipedia.org/wiki/Red–black_tree
http://www.cnblogs.com/skywang12345/p/3245399.html
http://shmilyaw-hotmail-com.iteye.com/blog/1836431
http://blog.csdn.net/speedme/article/details/18743445
http://blog.csdn.net/eson_15/article/details/51144079
http://blog.csdn.net/v_july_v/article/details/6105630
http://dongxicheng.org/structure/red-black-tree/



树是许多成熟的项目所使用的基本数据结构，也是面试常考、程序员必备的重中之重。

1 底层基础概念
1.1 平衡树
所谓平衡树的平衡，就是树上某节点的所有子树的高度差的绝对值不超过1，该规律应用在树中所有节点上。如果该树是二叉树，则该树是常见的是平衡二叉树。

1.2 平衡二叉树
满足平衡树概念的二叉树，常见实现有：

红黑树
AVL树（平衡二叉树）
替罪羊树
Treap（树堆）
伸展树
最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。

1.2.1 二叉树的平衡方法
二叉左旋

一棵二叉平衡树的子树，根是Root，左子树是x，右子树的根为RootR，右子树的两个孩子树分别为RLeftChild和RRightChild。则左旋后，该子树的根为RootR，右子树为RRightChild，左子树的根为Root，Root的两个孩子树分别为x（左）和RLeftChild（右）。

二叉右旋

一棵二叉平衡树的子树，根是Root，右子树是x，左子树的根为RootL，左子树的两个孩子树分别为LLeftChild和LRightChild。则右旋后，该子树的根为RootL，左子树为LLeftChild，右子树的根为Root，Root的两个孩子树分别为LRightChild（左）和x（右）。

1.3 查找树（搜索树）
《算法导论》的定义：

查找树是一种数据结构，既可以用作字典，也可以用作优先队列。

查找树支持多种动态集合操作：SEARCH、MINIMUM、MAXIMUM、PREDECESSOR（前）、SUCCESSOR（后）、INSERT以及DELETE。

查找树是有序的，具体表现为：树上某节点的左边所有子树的值<该节点的值<该节点的右边所有子树的值。该规律应用在树中所有节点上。如果该树是二叉树，则该树是常见的是二叉查找（搜索）树。

1.4 二叉查找（搜索、排序）树(BINARY SEARCH/SORT TREE)
在二叉查找树上执行上述基本操作的时间与树的高度成正比。下图所示是二叉查找树：

《常见“树”概念解析（1）》binary-search-tree

用链表表示的话，每个节点都是一个对象，节点中的data称之为Key关键字。

2 常见数据结构
2.1 红黑树
2.1.1 《算法导论（第2版）》的定义：
红黑树（Red Black Tree） 是一种自平衡二叉查找树。在每个节点上增加一个存储位表示节点的颜色，可以是红或者黑。通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有任何一条路径会比其他路径长出两倍。

上图二叉查找树中，一个节点对象有四个域：key，left，right，p（parent），而红黑树有五个域：color， key，left，right，p。key域不为空的这里称之为内节点，而key域为空的并且没有一个子节点或父节点的Nil节点视为外节点（如果有不懂请看下图）。

一颗二叉查找树如果满足如下的红黑性质，则是红黑树：

每个节点或是红的或是黑的。
根节点是黑的。
叶节点（Nil节点）是黑的。
如果一个节点是红的，它两个孩子节点都是黑的。
对每个节点，从该节点到其子孙节点的所有路径包含相同数目的黑色节点。

============================================================
1. 左旋
对x进行左旋，意味着"将x变成一个左节点"。
左旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。
复制代码
LEFT-ROTATE(T, x)
01  y ← right[x]            // 前提：这里假设x的右孩子为y。下面开始正式操作
02  right[x] ← left[y]      // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子
03  p[left[y]] ← x          // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x
04  p[y] ← p[x]             // 将 “x的父亲” 设为 “y的父亲”
05  if p[x] = nil[T]
06  then root[T] ← y                 // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点
07  else if x = left[p[x]]
08            then left[p[x]] ← y    // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”
09            else right[p[x]] ← y   // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”
10  left[y] ← x             // 将 “x” 设为 “y的左孩子”
11  p[x] ← y                // 将 “x的父节点” 设为 “y”
复制代码
理解左旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。

2. 右旋
对x进行左旋，意味着"将x变成一个左节点"。
右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。

复制代码
RIGHT-ROTATE(T, y)
01  x ← left[y]             // 前提：这里假设y的左孩子为x。下面开始正式操作
02  left[y] ← right[x]      // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子
03  p[right[x]] ← y         // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y
04  p[x] ← p[y]             // 将 “y的父亲” 设为 “x的父亲”
05  if p[y] = nil[T]
06  then root[T] ← x                 // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点
07  else if y = right[p[y]]
08            then right[p[y]] ← x   // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”
09            else left[p[y]] ← x    // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”
10  right[x] ← y            // 将 “y” 设为 “x的右孩子”
11  p[y] ← x                // 将 “y的父节点” 设为 “x”
复制代码
理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。

旋转总结：
(01) 左旋 和 右旋 是相对的两个概念，原理类似。理解一个也就理解了另一个。
(02) 下面谈谈如何区分 左旋 和 右旋。
在实际应用中，若没有彻底理解 左旋 和 右旋，可能会将它们混淆。下面谈谈我对如何区分 左旋 和 右旋 的理解。

3. 区分 左旋 和 右旋

仔细观察上面"左旋"和"右旋"的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。

其实红黑树的插入操作不是很难，甚至比AVL树的插入操作还更简单些。但删除操作就远远比AVL树复杂得多，下面就介绍红黑树的删除操作。

==============
红黑树上结点的删除
红黑树本身是一棵二叉查找树，它的删除和二叉查找树的删除类似。首先要找到真正的删除点，当被删除结点n存在左右孩子时，真正的删除点应该是n的中序遍在前驱，关于这一点请复习二叉查找树的删除。如图9所示，当删除结点20时，实际被删除的结点应该为18，结点20的数据变为18。
所以可以推断出，在进行删除操作时，真正的删除点必定是只有一个孩子或没有孩子的结点。而根据红黑树的性质可以得出以下两个结论：

1、 删除操作中真正被删除的必定是只有一个红色孩子或没有孩子的结点。
2、 如果真正的删除点是一个红色结点，那么它必定是一个叶子结点。

==========
AVL树：平衡二叉树

LL:  平衡因子同为负----->右旋转

RR：平衡因子同为正------->左旋转

LR和RR：平衡因子异号，则先化为同号后按同号处理
LR:先对平衡因子为正的结点进行左旋转，再右旋转
RL:先对平衡因子为负的结点进行右旋转，再左旋转


